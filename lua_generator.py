"""
Lua Generator

Generates GearSwap-compatible Lua files from optimization results.

Supports:
- Pure data tables
- set_combine() for derived sets (only outputs differences)
- Magic, TP, WS, Idle, and Defense set patterns
- Stat comments for melee and magic sets
"""

import os
from typing import Dict, List, Optional, Any, TextIO, Tuple, Set
from dataclasses import dataclass, field
from datetime import datetime

from models import GearSet, ItemInstance, Slot, SLOT_NAMES, Stats


@dataclass
class SetDefinition:
    """
    Represents a gear set with optional base set for set_combine.
    """
    gear_set: GearSet
    base_path: Optional[str] = None  # If set, use set_combine with this base
    comment: Optional[str] = None    # Optional custom comment


class LuaGenerator:
    """
    Generates GearSwap Lua code from gear sets.
    
    Supports both standalone sets and set_combine() for derived sets.
    """
    
    def __init__(self, indent: str = '    '):
        self.indent = indent
    
    # =========================================================================
    # Main Generation Methods
    # =========================================================================
    
    def generate_sets_table(
        self,
        sets: Dict[str, SetDefinition],
        include_comments: bool = True
    ) -> str:
        """
        Generate a complete sets table.
        
        Args:
            sets: Dictionary of set_name -> SetDefinition
            include_comments: Whether to include stat comments
        
        Returns:
            Lua code string
        """
        lines = []
        
        # Header comment
        if include_comments:
            lines.append('-- Generated by GearSwap Optimizer')
            lines.append(f'-- Generated: {datetime.now().isoformat()}')
            lines.append('')
        
        # Generate each set
        # Sort to ensure base sets come before derived sets
        sorted_paths = self._sort_set_paths(sets)
        
        for set_path in sorted_paths:
            set_def = sets[set_path]
            lines.extend(self._generate_set_definition(
                set_path, set_def, sets, include_comments
            ))
            lines.append('')
        
        return '\n'.join(lines)
    
    def generate_set(
        self,
        set_name: str,
        gear_set: GearSet,
        include_comments: bool = True
    ) -> str:
        """
        Generate Lua code for a single standalone gear set.
        
        Args:
            set_name: Full set path (e.g., "precast.WS['Savage Blade']")
            gear_set: The gear set to generate
            include_comments: Whether to include stat comments
        
        Returns:
            Lua code string
        """
        set_def = SetDefinition(gear_set=gear_set)
        lines = self._generate_set_definition(set_name, set_def, {}, include_comments)
        return '\n'.join(lines)
    
    # =========================================================================
    # Internal Generation Methods
    # =========================================================================
    
    def _sort_set_paths(self, sets: Dict[str, SetDefinition]) -> List[str]:
        """
        Sort set paths so base sets come before derived sets.
        """
        # Separate base sets from combined sets
        base_sets = []
        combined_sets = []
        
        for path, set_def in sets.items():
            if set_def.base_path is None:
                base_sets.append(path)
            else:
                combined_sets.append(path)
        
        # Sort each group alphabetically for consistency
        base_sets.sort()
        combined_sets.sort()
        
        return base_sets + combined_sets
    
    def _generate_set_definition(
        self,
        set_path: str,
        set_def: SetDefinition,
        all_sets: Dict[str, SetDefinition],
        include_comments: bool
    ) -> List[str]:
        """Generate lines for a set definition (standalone or combined)."""
        
        if set_def.base_path and set_def.base_path in all_sets:
            # Generate as set_combine
            return self._generate_combined_set(
                set_path, set_def, all_sets, include_comments
            )
        else:
            # Generate as standalone set
            return self._generate_standalone_set(
                set_path, set_def.gear_set, include_comments, set_def.comment
            )
    
    def _generate_standalone_set(
        self,
        set_name: str,
        gear_set: GearSet,
        include_comments: bool,
        custom_comment: Optional[str] = None
    ) -> List[str]:
        """Generate lines for a standalone set."""
        lines = []
        
        # Custom comment or stat comment
        if include_comments:
            if custom_comment:
                lines.append(f'-- {custom_comment}')
            elif gear_set.items:
                stats = gear_set.total_stats
                stat_summary = self._format_stats_comment(stats, gear_set)
                if stat_summary:
                    lines.append(f'-- {stat_summary}')
        
        # Set definition
        lines.append(f'sets.{set_name} = {{')
        
        # Generate slot assignments in logical order
        slot_order = [
            Slot.MAIN, Slot.SUB, Slot.RANGE, Slot.AMMO,
            Slot.HEAD, Slot.NECK, Slot.LEFT_EAR, Slot.RIGHT_EAR,
            Slot.BODY, Slot.HANDS, Slot.LEFT_RING, Slot.RIGHT_RING,
            Slot.BACK, Slot.WAIST, Slot.LEGS, Slot.FEET,
        ]
        
        for slot in slot_order:
            item = gear_set.items.get(slot)
            if item:
                slot_name = SLOT_NAMES[slot]
                item_lua = self._format_item(item)
                lines.append(f'{self.indent}{slot_name}={item_lua},')
        
        lines.append('}')
        
        return lines
    
    def _generate_combined_set(
        self,
        set_path: str,
        set_def: SetDefinition,
        all_sets: Dict[str, SetDefinition],
        include_comments: bool
    ) -> List[str]:
        """Generate lines for a set using set_combine."""
        lines = []
        
        base_def = all_sets.get(set_def.base_path)
        if not base_def:
            # Fallback to standalone if base not found
            return self._generate_standalone_set(
                set_path, set_def.gear_set, include_comments, set_def.comment
            )
        
        # Calculate the difference between this set and base set
        diff_items = self._diff_gear_sets(base_def.gear_set, set_def.gear_set)
        
        if not diff_items:
            # No differences - just reference the base set
            lines.append(f'sets.{set_path} = sets.{set_def.base_path}')
            return lines
        
        # Comment
        if include_comments:
            if set_def.comment:
                lines.append(f'-- {set_def.comment}')
            elif set_def.gear_set.items:
                stats = set_def.gear_set.total_stats
                stat_summary = self._format_stats_comment(stats, set_def.gear_set)
                if stat_summary:
                    lines.append(f'-- {stat_summary}')
        
        # Generate set_combine
        lines.append(f'sets.{set_path} = set_combine(sets.{set_def.base_path}, {{')
        
        # Output only the differing slots
        slot_order = [
            Slot.MAIN, Slot.SUB, Slot.RANGE, Slot.AMMO,
            Slot.HEAD, Slot.NECK, Slot.LEFT_EAR, Slot.RIGHT_EAR,
            Slot.BODY, Slot.HANDS, Slot.LEFT_RING, Slot.RIGHT_RING,
            Slot.BACK, Slot.WAIST, Slot.LEGS, Slot.FEET,
        ]
        
        for slot in slot_order:
            if slot in diff_items:
                slot_name = SLOT_NAMES[slot]
                item = diff_items[slot]
                if item is None:
                    # Slot was removed (empty in derived set)
                    lines.append(f'{self.indent}{slot_name}=empty,')
                else:
                    item_lua = self._format_item(item)
                    lines.append(f'{self.indent}{slot_name}={item_lua},')
        
        lines.append('})')
        
        return lines
    
    def _diff_gear_sets(
        self,
        base: GearSet,
        derived: GearSet
    ) -> Dict[Slot, Optional[ItemInstance]]:
        """
        Calculate the difference between two gear sets.
        
        Returns dict of slot -> item for slots that differ.
        None value means slot should be emptied.
        """
        diff = {}
        
        all_slots = set(base.items.keys()) | set(derived.items.keys())
        
        for slot in all_slots:
            base_item = base.items.get(slot)
            derived_item = derived.items.get(slot)
            
            # Check if items are different
            if not self._items_equal(base_item, derived_item):
                diff[slot] = derived_item  # None if slot removed
        
        return diff
    
    def _items_equal(
        self,
        item1: Optional[ItemInstance],
        item2: Optional[ItemInstance]
    ) -> bool:
        """Check if two items are equal (same name and augments)."""
        if item1 is None and item2 is None:
            return True
        if item1 is None or item2 is None:
            return False
        
        # Compare names
        if item1.name != item2.name:
            return False
        
        # Compare augments
        aug1 = tuple(item1.augments_raw) if item1.augments_raw else ()
        aug2 = tuple(item2.augments_raw) if item2.augments_raw else ()
        
        return aug1 == aug2
    
    # =========================================================================
    # Item Formatting
    # =========================================================================
    
    def _format_item(self, item: ItemInstance) -> str:
        """
        Format an item for Lua output.
        
        Handles augmented items with proper GearSwap syntax.
        Uses single quotes for augment strings (Lua convention).
        """
        if not item.augments_raw:
            # Simple item - just the name
            return f'"{item.name}"'
        
        # Augmented item - use table syntax
        # { name="Item Name", augments={'aug1', 'aug2', ...} }
        
        # Format augments using single quotes (Lua convention)
        # Internal double quotes like "Fast Cast" are fine inside single quotes
        aug_parts = []
        for aug in item.augments_raw:
            if aug and aug != 'none' and aug != '':
                if isinstance(aug, str):
                    # Use single quotes - internal double quotes are preserved
                    aug_parts.append(f"'{aug}'")
                else:
                    # Numeric augment - keep as number
                    aug_parts.append(str(aug))
        
        if not aug_parts:
            return f'"{item.name}"'
        
        aug_str = ', '.join(aug_parts)
        return f'{{ name="{item.name}", augments={{{aug_str}}} }}'
    
    # =========================================================================
    # Stat Comment Formatting
    # =========================================================================
    
    def _format_stats_comment(
        self,
        stats: Stats,
        gear_set: Optional[GearSet] = None
    ) -> str:
        """
        Format key stats as a comment.
        
        Automatically detects set type and shows relevant stats.
        """
        parts = []
        
        # Detect set type based on stats present
        is_magic_set = self._is_magic_set(stats)
        is_dt_set = self._is_dt_set(stats)
        
        if is_magic_set:
            parts = self._format_magic_stats(stats)
        elif is_dt_set:
            parts = self._format_dt_stats(stats)
        else:
            parts = self._format_melee_stats(stats)
        
        return ' '.join(parts)
    
    def _is_magic_set(self, stats: Stats) -> bool:
        """Detect if this is primarily a magic set."""
        magic_indicators = [
            getattr(stats, 'magic_attack', 0),
            getattr(stats, 'magic_accuracy', 0),
            getattr(stats, 'magic_burst_bonus', 0),
            getattr(stats, 'magic_burst_bonus_ii', 0),
            getattr(stats, 'magic_damage', 0),
        ]
        melee_indicators = [
            getattr(stats, 'store_tp', 0),
            getattr(stats, 'double_attack', 0),
            getattr(stats, 'triple_attack', 0),
            getattr(stats, 'attack', 0),
        ]
        
        return sum(magic_indicators) > sum(melee_indicators)
    
    def _is_dt_set(self, stats: Stats) -> bool:
        """Detect if this is primarily a DT/defensive set."""
        dt = abs(getattr(stats, 'damage_taken', 0))
        pdt = abs(getattr(stats, 'physical_dt', 0))
        mdt = abs(getattr(stats, 'magical_dt', 0))
        
        # If significant DT values, it's a DT set
        return (dt + pdt + mdt) >= 2000  # 20% or more total
    
    def _format_melee_stats(self, stats: Stats) -> List[str]:
        """Format stats for melee/TP sets."""
        parts = []
        
        # Primary stats (only show if significant)
        for stat in ['STR', 'DEX', 'VIT', 'AGI']:
            val = getattr(stats, stat, 0)
            if val and val >= 10:
                parts.append(f'{stat}:{val}')
        
        # Key combat stats
        if getattr(stats, 'accuracy', 0):
            parts.append(f'Acc:{stats.accuracy}')
        if getattr(stats, 'attack', 0):
            parts.append(f'Atk:{stats.attack}')
        if getattr(stats, 'store_tp', 0):
            parts.append(f'STP:{stats.store_tp}')
        
        # Haste (convert from basis points)
        gear_haste = getattr(stats, 'gear_haste', 0)
        if gear_haste:
            parts.append(f'Haste:{gear_haste // 100}%')
        
        # Multi-attack (convert from basis points)
        da = getattr(stats, 'double_attack', 0)
        ta = getattr(stats, 'triple_attack', 0)
        qa = getattr(stats, 'quad_attack', 0)
        if da:
            parts.append(f'DA:{da // 100}%')
        if ta:
            parts.append(f'TA:{ta // 100}%')
        if qa:
            parts.append(f'QA:{qa // 100}%')
        
        # Crit
        crit = getattr(stats, 'crit_rate', 0)
        if crit:
            parts.append(f'Crit:{crit // 100}%')
        
        # DT if present
        dt = getattr(stats, 'damage_taken', 0)
        if dt:
            parts.append(f'DT:{dt // 100}%')
        
        return parts
    
    def _format_magic_stats(self, stats: Stats) -> List[str]:
        """Format stats for magic sets."""
        parts = []
        
        # Primary magic stats
        int_val = getattr(stats, 'INT', 0)
        mnd_val = getattr(stats, 'MND', 0)
        if int_val:
            parts.append(f'INT:{int_val}')
        if mnd_val:
            parts.append(f'MND:{mnd_val}')
        
        # Magic offense
        mab = getattr(stats, 'magic_attack', 0)
        mdmg = getattr(stats, 'magic_damage', 0)
        macc = getattr(stats, 'magic_accuracy', 0)
        if mab:
            parts.append(f'MAB:{mab}')
        if mdmg:
            parts.append(f'M.Dmg:{mdmg}')
        if macc:
            parts.append(f'M.Acc:{macc}')
        
        # Magic Burst Bonus (convert from basis points if needed)
        mbb = getattr(stats, 'magic_burst_bonus', 0)
        mbb_ii = getattr(stats, 'magic_burst_bonus_ii', 0)
        if mbb:
            # Check if it's in basis points (> 100) or percentage
            if mbb > 100:
                parts.append(f'MBB:{mbb // 100}%')
            else:
                parts.append(f'MBB:{mbb}%')
        if mbb_ii:
            if mbb_ii > 100:
                parts.append(f'MBB2:{mbb_ii // 100}%')
            else:
                parts.append(f'MBB2:{mbb_ii}%')
        
        # Fast Cast
        fc = getattr(stats, 'fast_cast', 0)
        if fc:
            if fc > 100:
                parts.append(f'FC:{fc // 100}%')
            else:
                parts.append(f'FC:{fc}%')
        
        # Magic skills
        ele_skill = getattr(stats, 'elemental_magic_skill', 0)
        dark_skill = getattr(stats, 'dark_magic_skill', 0)
        enf_skill = getattr(stats, 'enfeebling_magic_skill', 0)
        enh_skill = getattr(stats, 'enhancing_magic_skill', 0)
        if ele_skill:
            parts.append(f'Ele.Skill:{ele_skill}')
        if dark_skill:
            parts.append(f'Dark.Skill:{dark_skill}')
        if enf_skill:
            parts.append(f'Enf.Skill:{enf_skill}')
        if enh_skill:
            parts.append(f'Enh.Skill:{enh_skill}')
        
        return parts
    
    def _format_dt_stats(self, stats: Stats) -> List[str]:
        """Format stats for DT/defensive sets."""
        parts = []
        
        # DT stats (convert from basis points)
        dt = getattr(stats, 'damage_taken', 0)
        pdt = getattr(stats, 'physical_dt', 0)
        mdt = getattr(stats, 'magical_dt', 0)
        
        if dt:
            parts.append(f'DT:{dt // 100}%')
        if pdt:
            parts.append(f'PDT:{pdt // 100}%')
        if mdt:
            parts.append(f'MDT:{mdt // 100}%')
        
        # HP
        hp = getattr(stats, 'HP', 0)
        if hp:
            parts.append(f'HP:{hp}')
        
        # Defense
        defense = getattr(stats, 'defense', 0)
        if defense:
            parts.append(f'Def:{defense}')
        
        # Magic Evasion/Defense
        meva = getattr(stats, 'magic_evasion', 0)
        mdef = getattr(stats, 'magic_defense', 0)
        if meva:
            parts.append(f'M.Eva:{meva}')
        if mdef:
            parts.append(f'M.Def:{mdef}')
        
        # Refresh/Regen
        refresh = getattr(stats, 'refresh', 0)
        regen = getattr(stats, 'regen', 0)
        if refresh:
            parts.append(f'Refresh:{refresh}')
        if regen:
            parts.append(f'Regen:{regen}')
        
        return parts
    
    # =========================================================================
    # Full File Generation
    # =========================================================================
    
    def generate_full_file(
        self,
        sets: Dict[str, SetDefinition],
        job: str,
        player_name: Optional[str] = None,
        include_template: bool = True
    ) -> str:
        """
        Generate a complete GearSwap Lua file.
        
        Args:
            sets: Dictionary of set definitions
            job: Job abbreviation (e.g., 'THF')
            player_name: Optional player name for file
            include_template: Include basic GearSwap structure
        
        Returns:
            Complete Lua file content
        """
        lines = []
        
        # File header
        lines.append('---------------------------------------------------')
        lines.append(f'-- GearSwap file for {job}')
        if player_name:
            lines.append(f'-- Player: {player_name}')
        lines.append(f'-- Generated: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}')
        lines.append('-- Generated by GearSwap Optimizer')
        lines.append('---------------------------------------------------')
        lines.append('')
        
        if include_template:
            lines.append('function get_sets()')
            lines.append(f'{self.indent}-- Initialize sets')
            lines.append(f'{self.indent}sets = {{}}')
            lines.append(f'{self.indent}sets.precast = {{}}')
            lines.append(f'{self.indent}sets.precast.FC = {{}}')
            lines.append(f'{self.indent}sets.precast.JA = {{}}')
            lines.append(f'{self.indent}sets.precast.WS = {{}}')
            lines.append(f'{self.indent}sets.midcast = {{}}')
            lines.append(f'{self.indent}sets.idle = {{}}')
            lines.append(f'{self.indent}sets.engaged = {{}}')
            lines.append(f'{self.indent}sets.defense = {{}}')
            lines.append('')
            lines.append(f'{self.indent}-- Generated sets follow')
            lines.append('')
        
        # Generate all sets with proper indentation
        sorted_paths = self._sort_set_paths(sets)
        for set_path in sorted_paths:
            set_def = sets[set_path]
            set_lines = self._generate_set_definition(
                set_path, set_def, sets, include_comments=True
            )
            for line in set_lines:
                if include_template and line:
                    lines.append(f'{self.indent}{line}')
                else:
                    lines.append(line)
            lines.append('')
        
        if include_template:
            lines.append('end')
        
        return '\n'.join(lines)
    
    def generate_sets_only(self, sets: Dict[str, SetDefinition]) -> str:
        """
        Generate only the sets definitions (for inclusion in existing files).
        
        Args:
            sets: Dictionary of set definitions
        
        Returns:
            Lua code with just set definitions
        """
        lines = []
        lines.append('-- Generated sets (copy into your GearSwap file)')
        lines.append(f'-- Generated: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}')
        lines.append('')
        
        sorted_paths = self._sort_set_paths(sets)
        for set_path in sorted_paths:
            set_def = sets[set_path]
            lines.extend(self._generate_set_definition(
                set_path, set_def, sets, include_comments=True
            ))
            lines.append('')
        
        return '\n'.join(lines)
    
    def save_to_file(self, content: str, filepath: str):
        """Save generated Lua to a file."""
        os.makedirs(os.path.dirname(filepath) or '.', exist_ok=True)
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(content)


class SetBuilder:
    """
    Helper class to build set hierarchies for GearSwap.
    
    Supports both standalone sets and set_combine relationships.
    """
    
    def __init__(self):
        self.sets: Dict[str, SetDefinition] = {}
    
    # =========================================================================
    # Core Add Methods
    # =========================================================================
    
    def add_set(
        self,
        path: str,
        gear_set: GearSet,
        base_path: Optional[str] = None,
        comment: Optional[str] = None
    ):
        """
        Add a set at the given path.
        
        Args:
            path: Set path (e.g., "precast.WS['Savage Blade']")
            gear_set: The gear set
            base_path: Optional base set path for set_combine
            comment: Optional custom comment
        """
        self.sets[path] = SetDefinition(
            gear_set=gear_set,
            base_path=base_path,
            comment=comment
        )
    
    def add_combined_set(
        self,
        path: str,
        gear_set: GearSet,
        base_path: str,
        comment: Optional[str] = None
    ):
        """
        Add a set that combines with a base set.
        
        Only the differences will be output using set_combine().
        
        Args:
            path: Set path
            gear_set: The full gear set (differences calculated automatically)
            base_path: Path to the base set
            comment: Optional custom comment
        """
        self.add_set(path, gear_set, base_path=base_path, comment=comment)
    
    # =========================================================================
    # Engaged (TP) Sets
    # =========================================================================
    
    def add_engaged_set(self, gear_set: GearSet, comment: Optional[str] = None):
        """Add base engaged set (sets.engaged)."""
        self.add_set("engaged", gear_set, comment=comment or "Base TP set")
    
    def add_engaged_acc(self, gear_set: GearSet, comment: Optional[str] = None):
        """Add accuracy engaged set (sets.engaged.Acc)."""
        self.add_combined_set(
            "engaged.Acc", gear_set, "engaged",
            comment=comment or "Accuracy focused"
        )
    
    def add_engaged_dt(self, gear_set: GearSet, comment: Optional[str] = None):
        """Add DT hybrid engaged set (sets.engaged.DT)."""
        self.add_combined_set(
            "engaged.DT", gear_set, "engaged",
            comment=comment or "DT hybrid (survivability while engaged)"
        )
    
    def add_engaged_hybrid(self, gear_set: GearSet, comment: Optional[str] = None):
        """Add hybrid engaged set (sets.engaged.Hybrid)."""
        self.add_combined_set(
            "engaged.Hybrid", gear_set, "engaged",
            comment=comment or "Hybrid (TP + damage)"
        )
    
    # =========================================================================
    # Idle Sets
    # =========================================================================
    
    def add_idle_set(self, gear_set: GearSet, comment: Optional[str] = None):
        """Add base idle set (sets.idle)."""
        self.add_set("idle", gear_set, comment=comment or "Default idle")
    
    def add_idle_dt(self, gear_set: GearSet, comment: Optional[str] = None):
        """Add DT idle set (sets.idle.DT)."""
        self.add_combined_set(
            "idle.DT", gear_set, "idle",
            comment=comment or "DT focused idle"
        )
    
    def add_idle_refresh(self, gear_set: GearSet, comment: Optional[str] = None):
        """Add refresh idle set (sets.idle.Refresh)."""
        self.add_combined_set(
            "idle.Refresh", gear_set, "idle",
            comment=comment or "Refresh focused idle"
        )
    
    def add_idle_regen(self, gear_set: GearSet, comment: Optional[str] = None):
        """Add regen idle set (sets.idle.Regen)."""
        self.add_combined_set(
            "idle.Regen", gear_set, "idle",
            comment=comment or "Regen focused idle"
        )
    
    # =========================================================================
    # Defense Sets
    # =========================================================================
    
    def add_defense_dt(self, gear_set: GearSet, comment: Optional[str] = None):
        """Add pure DT defense set (sets.defense.DT)."""
        self.add_set("defense.DT", gear_set, comment=comment or "Pure DT (-50% cap)")
    
    def add_defense_pdt(self, gear_set: GearSet, comment: Optional[str] = None):
        """Add PDT defense set (sets.defense.PDT)."""
        self.add_set("defense.PDT", gear_set, comment=comment or "Physical DT focus")
    
    def add_defense_mdt(self, gear_set: GearSet, comment: Optional[str] = None):
        """Add MDT defense set (sets.defense.MDT)."""
        self.add_set("defense.MDT", gear_set, comment=comment or "Magical DT focus")
    
    # =========================================================================
    # Weaponskill Sets
    # =========================================================================
    
    def add_ws_set(
        self,
        ws_name: str,
        gear_set: GearSet,
        base_ws: Optional[str] = None,
        comment: Optional[str] = None
    ):
        """
        Add a weaponskill set.
        
        Args:
            ws_name: Weaponskill name (e.g., "Savage Blade")
            gear_set: The gear set
            base_ws: Optional base WS name to combine with
            comment: Optional comment
        """
        escaped = ws_name.replace("'", "\\'")
        path = f"precast.WS['{escaped}']"
        
        if base_ws:
            base_escaped = base_ws.replace("'", "\\'")
            base_path = f"precast.WS['{base_escaped}']"
            self.add_combined_set(path, gear_set, base_path, comment=comment)
        else:
            self.add_set(path, gear_set, comment=comment)
    
    def add_ws_base(self, gear_set: GearSet, comment: Optional[str] = None):
        """Add base WS set (sets.precast.WS)."""
        self.add_set("precast.WS", gear_set, comment=comment or "Default WS set")
    
    # =========================================================================
    # Job Ability Sets
    # =========================================================================
    
    def add_ja_set(
        self,
        ja_name: str,
        gear_set: GearSet,
        comment: Optional[str] = None
    ):
        """Add a job ability set."""
        escaped = ja_name.replace("'", "\\'")
        self.add_set(f"precast.JA['{escaped}']", gear_set, comment=comment)
    
    # =========================================================================
    # Fast Cast Sets
    # =========================================================================
    
    def add_fc_set(self, gear_set: GearSet, comment: Optional[str] = None):
        """Add base fast cast set (sets.precast.FC)."""
        self.add_set("precast.FC", gear_set, comment=comment or "Fast Cast")
    
    def add_fc_variant(
        self,
        variant: str,
        gear_set: GearSet,
        comment: Optional[str] = None
    ):
        """
        Add a fast cast variant (e.g., Cure, Enhancing).
        
        Args:
            variant: Variant name (e.g., "Cure", "Enhancing", "Impact")
            gear_set: The gear set
            comment: Optional comment
        """
        self.add_combined_set(
            f"precast.FC.{variant}", gear_set, "precast.FC",
            comment=comment or f"FC for {variant}"
        )
    
    # =========================================================================
    # Midcast Magic Sets
    # =========================================================================
    
    def add_midcast_set(
        self,
        spell_type: str,
        gear_set: GearSet,
        base_type: Optional[str] = None,
        comment: Optional[str] = None
    ):
        """
        Add a midcast set for a spell type.
        
        Args:
            spell_type: Spell type (e.g., "Elemental Magic", "Cure", "Drain")
            gear_set: The gear set
            base_type: Optional base spell type to combine with
            comment: Optional comment
        """
        # Handle quoted spell types (like 'Elemental Magic')
        if ' ' in spell_type or spell_type[0].isupper():
            path = f"midcast['{spell_type}']"
        else:
            path = f"midcast.{spell_type}"
        
        if base_type:
            if ' ' in base_type or base_type[0].isupper():
                base_path = f"midcast['{base_type}']"
            else:
                base_path = f"midcast.{base_type}"
            self.add_combined_set(path, gear_set, base_path, comment=comment)
        else:
            self.add_set(path, gear_set, comment=comment)
    
    def add_midcast_mb(
        self,
        spell_type: str,
        gear_set: GearSet,
        engaged: bool = False,
        comment: Optional[str] = None
    ):
        """
        Add a magic burst midcast set.
        
        Args:
            spell_type: Spell type (e.g., "Elemental Magic", "Dark Magic")
            gear_set: The gear set
            engaged: If True, this is for MB while engaged
            comment: Optional comment
        """
        if ' ' in spell_type:
            base_path = f"midcast['{spell_type}']"
            if engaged:
                path = f"midcast['{spell_type}'].MB.Engaged"
                default_comment = f"Magic Burst {spell_type} (engaged)"
            else:
                path = f"midcast['{spell_type}'].MB"
                default_comment = f"Magic Burst {spell_type}"
        else:
            base_path = f"midcast.{spell_type}"
            if engaged:
                path = f"midcast.{spell_type}.MB.Engaged"
                default_comment = f"Magic Burst {spell_type} (engaged)"
            else:
                path = f"midcast.{spell_type}.MB"
                default_comment = f"Magic Burst {spell_type}"
        
        self.add_combined_set(
            path, gear_set, base_path,
            comment=comment or default_comment
        )
    
    def add_midcast_resistant(
        self,
        spell_type: str,
        gear_set: GearSet,
        comment: Optional[str] = None
    ):
        """
        Add a resistant/accuracy variant of a midcast set.
        
        Args:
            spell_type: Spell type (e.g., "Elemental Magic")
            gear_set: The gear set
            comment: Optional comment
        """
        if ' ' in spell_type:
            path = f"midcast['{spell_type}'].Resistant"
            base_path = f"midcast['{spell_type}']"
        else:
            path = f"midcast.{spell_type}.Resistant"
            base_path = f"midcast.{spell_type}"
        
        self.add_combined_set(
            path, gear_set, base_path,
            comment=comment or f"{spell_type} (accuracy focus)"
        )
    
    # =========================================================================
    # Convenience Methods for Common Magic Types
    # =========================================================================
    
    def add_elemental_magic(self, gear_set: GearSet, comment: Optional[str] = None):
        """Add elemental magic midcast set."""
        self.add_midcast_set("Elemental Magic", gear_set, comment=comment or "Elemental nuking")
    
    def add_elemental_mb(self, gear_set: GearSet, engaged: bool = False, comment: Optional[str] = None):
        """Add elemental magic burst set."""
        self.add_midcast_mb("Elemental Magic", gear_set, engaged=engaged, comment=comment)
    
    def add_dark_magic(self, gear_set: GearSet, comment: Optional[str] = None):
        """Add dark magic midcast set."""
        self.add_midcast_set("Dark Magic", gear_set, comment=comment or "Dark Magic")
    
    def add_dark_mb(self, gear_set: GearSet, engaged: bool = False, comment: Optional[str] = None):
        """Add dark magic burst set."""
        self.add_midcast_mb("Dark Magic", gear_set, engaged=engaged, comment=comment)
    
    def add_enfeebling_magic(self, gear_set: GearSet, comment: Optional[str] = None):
        """Add enfeebling magic midcast set."""
        self.add_midcast_set("Enfeebling Magic", gear_set, comment=comment or "Enfeebling Magic")
    
    def add_enhancing_magic(self, gear_set: GearSet, comment: Optional[str] = None):
        """Add enhancing magic midcast set."""
        self.add_midcast_set("Enhancing Magic", gear_set, comment=comment or "Enhancing Magic")
    
    def add_healing_magic(self, gear_set: GearSet, comment: Optional[str] = None):
        """Add healing/cure midcast set."""
        self.add_midcast_set("Cure", gear_set, comment=comment or "Cure potency")
    
    def add_divine_magic(self, gear_set: GearSet, comment: Optional[str] = None):
        """Add divine magic midcast set."""
        self.add_midcast_set("Divine Magic", gear_set, comment=comment or "Divine Magic")
    
    # =========================================================================
    # Output Methods
    # =========================================================================
    
    def get_sets(self) -> Dict[str, SetDefinition]:
        """Get all defined sets."""
        return self.sets
    
    def generate(self, generator: Optional[LuaGenerator] = None) -> str:
        """Generate Lua code for all sets."""
        if generator is None:
            generator = LuaGenerator()
        return generator.generate_sets_table(self.sets)


# =============================================================================
# Convenience Functions
# =============================================================================

def generate_lua(sets: Dict[str, GearSet], **kwargs) -> str:
    """
    Convenience function to generate Lua from simple sets dict.
    
    For set_combine support, use SetBuilder instead.
    """
    generator = LuaGenerator()
    # Convert to SetDefinition format
    set_defs = {path: SetDefinition(gear_set=gs) for path, gs in sets.items()}
    return generator.generate_sets_table(set_defs, **kwargs)


def generate_file(
    sets: Dict[str, GearSet],
    job: str,
    filepath: str,
    **kwargs
):
    """Generate and save a complete GearSwap file."""
    generator = LuaGenerator()
    # Convert to SetDefinition format
    set_defs = {path: SetDefinition(gear_set=gs) for path, gs in sets.items()}
    content = generator.generate_full_file(set_defs, job, **kwargs)
    generator.save_to_file(content, filepath)
